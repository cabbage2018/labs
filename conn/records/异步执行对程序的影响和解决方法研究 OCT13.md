# 异步执行对程序的影响和解决方法研究 #

## 事由 ##
新近开发了一个数据接力项目，它这样工作
监听redis channel的消息，一旦接收到，从数据库查询订阅对象的列表
获取列表后通过signalR 订阅实时数据和事件警报，接收到数据COV 再送到mqtt topic

就这么简单的一个逻辑，实现起来却异常有趣。我用单元测试mocha 将各部件连接验证通过，再拼装，这样得到的结果是正确的； 但是实际程序里同样的逻辑模块却跑不通。这里是注册回调

```
postgresql.onRegister(signalr.channelize)
redis.onRegister(postgresql.stimulate)
let idlist = signalr.subscription()

```

仔细一想，mocha 框架借助it() 执行申明确保了顺序，而程序里必须实现自己的时序。
什么地方需要时序呢？最主要还是围绕signalR 订阅来的，首先我们要RESTful 请求获取token，再将该token 嵌入到wss 连接头部，这样才能正确connect 上远端server。只有当signalR client connected 状态后，再进行特定数据点订阅才有效，否则完全错误。单元测试时我事先固定了数据点列表，这样就不存在外部对数据库的依赖，这时在connect 事件触发器里的回调函数执行是符合前提条件的(但是如果采用植入一个外部回调，用于数据库更新数据列表时被调用，这时signalR 通路尚未建立，通路建立耗时3-6 秒间)。也就可以解释 npm test 效果强过npm start，单元测试强过正式运行。

## 解决方法 ##
一种是让各模块自行决定调用时间，另外一种是用上帝视角确定各模块前后顺序。
第一种实现简单，但是引入require 模块形成强耦合。
第二种需要测试各模块建立时间，关键这个时间还不是固定的跟服务器协议栈、网络拥塞状况有关，有可能出现在一个网络环境调试好的延时参数去到另外一个环境就无法工作，

## 进一步研究 ##
通过把这个过程写下来我发现有了一个新的思路，就是不再利用回调函数，而是直接传递数据 - 回调利在解耦但是引入了时序混乱；数据原本就是程序唯一关注的输入。直接在数据库更新到新版的数据点列表ObjectID 后放置到signalR 模块里，这样只要数据库访问比服务器实时数据订阅来的快，程序就能正确工作。

